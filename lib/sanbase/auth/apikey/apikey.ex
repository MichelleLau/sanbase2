defmodule Sanbase.Auth.Apikey do
  @moduledoc ~s"""
  Apikey combines and exposes in a transparent manner all the operations with the
  apikeys.

  Let's get some of the terminology straight:
  - User Token (or simply token) is a random string saved plain text in the database.
  The UT *is not* not the apikey and the apikey cannot be generated by knowing only the UT
  - Apikey is generated by a secret key and a UT. The enduser gets this apikey that will
  be used in the communication. By an apikey we can retrieve the owner (user) of it.
  """

  alias Sanbase.Auth.{
    Hmac,
    UserApiKeyToken,
    User
  }

  defguard is_non_empty_string(str) when is_binary(str) and str != ""

  @doc ~s"""
  Returns the User struct connected to the given apikey.
  Split the apikey by "_" and use the first part as a user id. Look for all
  user tokens for that ID and check if the apikey is generated from any of the
  tokens
  """
  @spec apikey_to_user(String.t()) :: {:ok, %User{}} | {:error, String.t()}
  def apikey_to_user(id_apikey) do
    with {:ok, {user_id, _rest}} <- split_apikey(id_apikey),
         {:ok, tokens} <- UserApiKeyToken.user_tokens(user_id) do
      if Hmac.apikey_valid?(user_id, tokens, id_apikey) do
        User.by_id(user_id)
      else
        {:error, "Apikey not valid"}
      end
    else
      error ->
        {:error, "Provided apikey is malformed. Inspecting error: #{inspect(error)}"}
    end
  end

  @doc ~s"""
  Generates a new User Token and stores it in the database.
  Generate the corresponding Apikey and return it.
  """
  @spec generate_apikey(%User{}) :: {:ok, String.t()} | {:error | String.t()}
  def generate_apikey(%User{id: user_id} = user) do
    with token when is_non_empty_string(token) <- Hmac.generate_token(),
         {:ok, _user_apikey_token} <- UserApiKeyToken.add_user_token(user, token),
         apikey when is_non_empty_string(apikey) <- Hmac.generate_apikey(user_id, token) do
      {:ok, apikey}
    else
      error ->
        {:error,
         "Error generating new apikey for user with id #{user_id}. Inspecting error: #{
           inspect(error)
         }"}
    end
  end

  @doc ~s"""
  Revokes the given apikey by removing its corresponding
  """
  @spec revoke_apikey(String.t()) :: :ok | {:error, String.t()}
  def revoke_apikey(id_apikey) do
    with {:ok, {user_id, apikey}} <- split_apikey(id_apikey),
         {:ok, tokens} <- UserApiKeyToken.user_tokens(user_id) do
      Enum.find(tokens, fn token ->
        Hmac.generate_apikey(user_id, token) == id_apikey
      end)
      |> case do
        nil ->
          {:error, "Apikey does not exist."}

        matched_token ->
          UserApiKeyToken.remove_user_token(user_id, matched_token)
          :ok
      end
    else
      error ->
        {:error, "Provided apikey is malformed. Inspecting error: #{inspect(error)}"}
    end
  end

  @doc ~s"""
  Return a list of all apikeys for a given user
  """
  @spec apikeys_list(%User{}) :: List.t()
  def apikeys_list(%User{id: user_id} = user) do
    with {:ok, tokens} <- UserApiKeyToken.user_tokens(user) do
      Enum.map(tokens, fn token ->
        Hmac.generate_apikey(user_id, token)
      end)
    else
      error ->
        []
    end
  end

  # Private functions

  # Returns a list `[user_id, apikey]`
  defp split_apikey(id_apikey) do
    [num_as_str, apikey] = String.split(id_apikey, "_", parts: 2)
    {num, ""} = Integer.parse(num_as_str)

    {:ok, {num, apikey}}
  end
end
